#!/usr/bin/env python3

import os, sys, re
import subprocess, shlex
import fnmatch
import collections, functools

class CliOptions:
    verbose = False
    super_verbose = False
    dry_run = False

def main():
    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument("-v", "--verbose", action="store_true")
    parser.add_argument("--dry-run", action="store_true")
    parser.add_argument("command", choices=[
        "add",
        "update", "status",
        "ls", "list",
        "rm", "remove",
        "mv", "rename",
    ])
    parser.add_argument("--dir")
    parser.add_argument("--new-dir")
    parser.add_argument("--url")
    parser.add_argument("--ref")
    parser.add_argument("--ref-sha1")
    parser.add_argument("--include-fnmatch", action="append")
    parser.add_argument("--exclude-fnmatch", action="append")

    args = parser.parse_args()
    if args.verbose:
        CliOptions.verbose = True
    if args.dry_run:
        CliOptions.dry_run = True
    if os.environ.get("GIT_VENDOR_SUPER_VERBOSE", ""):
        CliOptions.verbose = True
        CliOptions.super_verbose = True
    if args.command == "status":
        # 'status' is an alias for 'update --dry-run'
        args.command = "update"
        CliOptions.dry_run = True

    if args.command == "add":
        assert args.url and args.ref and args.dir
        do_add(args.url, args.ref, args.dir, args.include_fnmatch, args.exclude_fnmatch)
    elif args.command == "update":
        do_update()
    elif args.command in ("ls", "list"):
        do_list()
    elif args.command in ("rm", "remove"):
        assert args.dir
        do_remove(args.dir)
    elif args.command in ("mv", "rename"):
        assert args.dir and args.new_dir
        do_rename(args.dir, args.new_dir)
    else: assert False

def do_add(url, ref, dir, include_fnmatch, exclude_fnmatch):
    path_in_repo = validate_dir(dir, "--dir")
    validate_url(url)
    validate_ref(ref)
    # validate existing config file, if any.
    read_config_file()

    new_config_item = ConfigItem()
    new_config_item.url = url
    new_config_item.ref = ref
    new_config_item.dir = path_in_repo
    if include_fnmatch:
        new_config_item.include_fnmatch = include_fnmatch
    if exclude_fnmatch:
        new_config_item.exclude_fnmatch = exclude_fnmatch

    download_the_thing(new_config_item, NEW_SECTION)

def do_update():
    for section_index, config_item in enumerate(read_config_file()):
        download_the_thing(config_item, section_index)

def do_list():
    for config_item in read_config_file():
        print("{} ({})".format(config_item.dir, config_item.ref))

def do_remove(actual_dir):
    _, section_index = find_config_item_by_dir(actual_dir)
    edit_config_file(None, section_index)

    if CliOptions.dry_run:
        print("")
        print("would delete tree: " + os.path.normpath(actual_dir))
        print("")
    else:
        git("rm",
            "-r", "-q", "--force",
            "--",
            actual_dir,
            mode="mutating")
        # Tell the user to proceed with a git commit.
        print("Changes staged to be committed:")
        git("diff",
            "--cached", "--shortstat",
            mode="inherit_stdout")
        print("")
        print("Use \"git commit\" to proceed with the commit.")

def do_rename(actual_dir, actual_new_dir):
    config_item, section_index = find_config_item_by_dir(actual_dir)
    config_item.dir = validate_dir(actual_new_dir, "--new-dir")
    edit_config_file(config_item, section_index)

    # Trailing slashes on this parameter ruin everything.
    actual_new_dir = os.path.normpath(actual_new_dir)

    if CliOptions.dry_run:
        print("")
        print("would move tree: {} -> {}".format(
            shlex.quote(os.path.normpath(actual_dir)),
            shlex.quote(actual_new_dir),
        ))
        print("")
    else:
        os.makedirs(os.path.dirname(actual_new_dir), exist_ok=True)
        git("mv",
            os.path.normpath(actual_dir),
            actual_new_dir,
            mode="mutating")
        # Tell the user to proceed with a git commit.
        print("Changes staged to be committed:")
        git("diff",
            "--cached", "--shortstat",
            mode="inherit_stdout")
        print("")
        print("Use \"git commit\" to proceed with the commit.")

def find_config_item_by_dir(actual_dir):
    repo_root = get_repo_root()
    path_in_repo = os.path.normpath(os.path.relpath(actual_dir, repo_root)).replace(os.path.sep, "/")
    for section_index, config_item in enumerate(read_config_file()):
        if config_item.dir == path_in_repo:
            return (config_item, section_index)
    sys.exit("\n".join("ERROR: " + line for line in [
        "dir is not vendored content: " + path_in_repo,
        "tip: try \"git-vendor list\"",
    ]))

def download_the_thing(config_item, section_index):

    # Fetch the latest external info.
    def should_fetch():
        # We'd like to just fetch, but `git fetch` produces trash output when there's nothing to do.
        # So first check if we would fetch anything, then do the fetch.
        if config_item.ref_sha1 == None:
            return True
        try:
            ours = git("rev-parse",
                "--verify",
                config_item.ref_sha1,
                suppress_stderr=True,
                mode="single_line")
        except subprocess.CalledProcessError:
            # The object has been gc'ed.
            return True
        remote_lines = git("ls-remote",
            config_item.url,
            config_item.ref,
            mode="newline_terminated_lines")
        if len(remote_lines) != 1:
            return True
        # e.g. "615624c2c2cfbed7e30a158493b704231b14ff8e\trefs/heads/main"
        theirs = remote_lines[0].split("\t", 1)[0]
        return ours != theirs
    if should_fetch():
        external_ref_local_name = "refs/vendor/fetch_head"
        git("fetch",
            "--no-tags", "--force",
            "--depth", "1",
            config_item.url,
            "{}:{}".format(config_item.ref, external_ref_local_name),
            mode="inherit_stdout")

        external_commit_object_name = git("rev-parse",
            "--verify",
            external_ref_local_name,
            mode="single_line")
        config_item.ref_sha1 = external_commit_object_name
        edit_config_file(config_item, section_index)

    vendored_tree_object_name = get_git_commit_tree_object_name(config_item.ref_sha1)
    if len(config_item.include_fnmatch) + len(config_item.exclude_fnmatch) > 0:
        vendored_tree_object_name = filter_tree(vendored_tree_object_name, config_item.include_fnmatch, config_item.exclude_fnmatch)

    current_complete_tree_object_name = git(
        "write-tree",
        mode="single_line")
    new_complete_tree_object_name = insert_tree_at_path(current_complete_tree_object_name, vendored_tree_object_name, config_item.dir)
    if current_complete_tree_object_name == new_complete_tree_object_name:
        # Already up to date.
        if not CliOptions.dry_run:
            print("Already up to date.")
        return

    if CliOptions.dry_run:
        # Show a diff of the incoming changes.
        print("")
        print("changes to to be applied to: " + config_item.dir)
        git("diff",
            "--shortstat",
            current_complete_tree_object_name, new_complete_tree_object_name,
            mode="inherit_stdout")
    else:
        # Update the index.
        git("read-tree",
            new_complete_tree_object_name,
            mode="mutating")
        # Update the work tree.
        repo_root = get_repo_root()
        actual_dir = os.path.join(repo_root, config_item.dir)
        os.makedirs(actual_dir, exist_ok=True)
        git(
            "--work-tree", actual_dir,
            "restore",
            "--source", vendored_tree_object_name,
            ".",
            mode="mutating")

        # Tell the user to proceed with a git commit.
        print("Changes staged to be committed:")
        git("diff",
            "--cached", "--shortstat",
            mode="inherit_stdout")
        print("")
        print("Use \"git commit\" to proceed with the commit.")

class ConfigItem:
    def __init__(self):
        self.dir = None
        self.url = None
        self.ref = None
        self.ref_sha1 = None
        self.include_fnmatch = []
        self.exclude_fnmatch = []
config_name_to_field_name = {
    k.replace("_", "-"): k
    for k in ConfigItem().__dict__.keys()
}
required_config_property_names = ["dir", "url", "ref"]
config_name_order = ["dir", "url", "ref", "ref-sha1", "include-fnmatch", "exclude-fnmatch"]
assert set(config_name_order) == set(config_name_to_field_name.keys())
assert set(required_config_property_names) <= set(config_name_order)

def read_config_file():
    repo_root = get_repo_root()
    config_file_path = os.path.join(repo_root, ".git-vendor-config")
    try:
        with open(config_file_path) as f:
            lines = list(f)
    except FileNotFoundError:
        lines = []
    if len(lines) == 0:
        return []

    sections = []
    current_config_item = ConfigItem()
    current_config_item_has_any_properties = False
    def line_error(line_index, msg):
        sys.exit("{}:{}: error: {}\n{}\n{}".format(
            os.path.relpath(config_file_path), line_index + 1, msg,
            lines[line_index].rstrip(),
            "^" * len(lines[line_index].rstrip()),
        ))
    def flush_section(line_index):
        nonlocal current_config_item_has_any_properties, current_config_item
        if not current_config_item_has_any_properties:
            line_error(line_index, "empty section?")
        for required_property in required_config_property_names:
            if current_config_item.__dict__[required_property] == None:
                line_error(line_index, "missing required property: {}".format(required_property))
        current_config_item.dir
        sections.append(current_config_item)
        current_config_item = ConfigItem()
        current_config_item_has_any_properties = False

    for line_index, line in enumerate(lines):
        line = line.strip()
        if line[:1] in ("", "#"):
            # Blank line or comment.
            continue

        if line == "---":
            flush_section(line_index)
            continue

        try:
            name, value = line.split("=", 1)
        except ValueError:
            line_error(line_index, "Syntax error")
        name = name.strip()
        value = value.strip()
        try:
            field_name = config_name_to_field_name[name]
        except KeyError:
            line_error(line_index, "unrecognized property name: " + repr(name))

        if current_config_item.__dict__[field_name] == None:
            current_config_item.__dict__[field_name] = value
        elif type(current_config_item.__dict__[field_name]) == list:
            current_config_item.__dict__[field_name].append(value)
        else:
            line_error(line_index, "scalar property specified more than once: " + repr(name))
        current_config_item_has_any_properties = True

    flush_section(len(lines) - 1)

    return sections

NEW_SECTION = -1
def edit_config_file(new_config_item, section_index):
    repo_root = get_repo_root()
    config_file_path = os.path.join(repo_root, ".git-vendor-config")
    try:
        with open(config_file_path) as f:
            lines = list(f)
    except FileNotFoundError:
        if section_index != NEW_SECTION:
            raise
        lines = []
    if len(lines) == 0:
        lines = [
            "# This is a git-vendor config file.",
            "# For details see https://github.com/thejoshwolfe/git-vendor/blob/main/README.md",
            "",
        ]

    theres_at_least_one_section = False
    current_section_index = 0
    property_new_line_indexes = collections.defaultdict(list, {
        # "dir": 3,
        # "include_fnmatch": [4, 5],
    })
    new_lines = []
    def flush_section():
        nonlocal current_section_index
        if new_config_item == None or current_section_index != section_index:
            current_section_index += 1
            return
        current_section_index += 1

        # These will be sorted backwards, and must be processed in this order:
        EDIT = -1
        DELETE = -2
        INSERT = -3
        line_edits = [
            # (index, DELETE),
            # (index, INSERT or EDIT, line),
        ]
        def check_edit_value(line_index, new_value):
            old_line = new_lines[line_index]
            old_value_start_index = old_line.index("=") + 1
            while old_line[old_value_start_index:old_value_start_index+1].isspace():
                old_value_start_index += 1
            old_value = old_line[old_value_start_index:].rstrip()
            if old_value == new_value:
                # Already correct.
                return
            # Edit
            new_line = old_line[:old_value_start_index] + new_value
            line_edits.append((line_index, EDIT, new_line))
        last_seen_property_line = None # Should always be initialized by the required fields.
        for name in config_name_order:
            field_name = config_name_to_field_name[name]
            if new_config_item.__dict__[field_name] == None:
                # Scalar property shouldn't exist.
                if field_name in property_new_line_indexes:
                    line_edits.append((property_new_line_indexes[field_name], DELETE))
                continue
            if new_config_item.__dict__[field_name] == []:
                # List property shouldn't exist.
                if field_name in property_new_line_indexes:
                    for line_index in property_new_line_indexes[field_name]:
                        delete_indexes.extend((line_index, None))
                continue
            if type(new_config_item.__dict__[field_name]) == list:
                # List property should have values.
                for i in range(max(len(new_config_item.__dict__[field_name]), len(property_new_line_indexes[field_name]))):
                    if i >= len(new_config_item.__dict__[field_name]):
                        # Delete extraneous values.
                        line_edits.append((property_new_line_indexes[field_name][i], DELETE))
                    elif i >= len(property_new_line_indexes[field_name]):
                        # Add new values.
                        line_edits.append((last_seen_property_line + 1, INSERT, "{}={}".format(name, new_config_item.__dict__[field_name][i])))
                    else:
                        # Check/edit existing values.
                        check_edit_value(property_new_line_indexes[field_name][i], new_config_item.__dict__[field_name][i])
                        last_seen_property_line = property_new_line_indexes[field_name][i]
            else:
                # Scalar property should have a value.
                if field_name in property_new_line_indexes:
                    # Check/edit existing value.
                    check_edit_value(property_new_line_indexes[field_name], new_config_item.__dict__[field_name])
                    # Note that this block of code should execute before any other,
                    # so this is where this variable gets initialized the first time:
                    last_seen_property_line = property_new_line_indexes[field_name]
                else:
                    # Add new value.
                    line_edits.append((last_seen_property_line + 1, INSERT, "{}={}".format(name, new_config_item.__dict__[field_name])))

        # Process line edits.
        for edit in sorted(line_edits, reverse=True):
            line_index = edit[0]
            edit_code = edit[1]
            if edit_code == EDIT:
                new_lines[line_index] = edit[2]
            elif edit_code == DELETE:
                del new_lines[line_index]
            elif edit_code == INSERT:
                new_lines[line_index:line_index] = [edit[2]]
            else: assert False

    for line in lines:
        if new_config_item == None and current_section_index == section_index:
            # We're deleting this section.
            if not theres_at_least_one_section and line.lstrip()[:1] == "#":
                # This is comments before the first section starts, so don't actually delete this part yet.
                new_lines.append(line)
                continue
            elif line.strip() == "---":
                if current_section_index == 0:
                    # This is the separator at the end of the first section, which we are deleting.
                    flush_section()
                    continue
                else:
                    # This is the separator at the end of the section we're deleting,
                    # but we already deleted the separator at the beginning of this section so keep this one.
                    pass
            else:
                # This is the content of the section we're deleting. Goodbye.
                theres_at_least_one_section = True
                continue

        if line.lstrip()[:1] in ("", "#"):
            # Blank line or comment.
            new_lines.append(line)
            continue

        if line.strip() == "---":
            flush_section()
            if new_config_item == None and current_section_index == section_index:
                # We're about to delete the next section, so omit this separator.
                pass
            else:
                new_lines.append(line)
            continue

        theres_at_least_one_section = True
        if current_section_index != section_index:
            # not the section we're looking for
            new_lines.append(line)
            continue

        try:
            name, _ = line.split("=", 1)
        except ValueError:
            # i don't care.
            new_lines.append(line)
            continue
        name = name.strip()
        try:
            field_name = config_name_to_field_name[name]
        except KeyError:
            # i don't care.
            new_lines.append(line)
            continue
        if type(new_config_item.__dict__[field_name]) == list:
            property_new_line_indexes[field_name].append(len(new_lines))
        else:
            property_new_line_indexes[field_name] = len(new_lines)
        new_lines.append(line)

    flush_section()
    total_sections = current_section_index

    if section_index == NEW_SECTION:
        # Create a new section.
        if theres_at_least_one_section:
            # Insert a separator.
            if new_lines[-1] != "":
                new_lines.append("")
            new_lines.append("---")
            new_lines.append("")

        for name in config_name_order:
            field_name = config_name_to_field_name[name]
            if new_config_item.__dict__[field_name] in (None, []):
                continue
            if type(new_config_item.__dict__[field_name]) == list:
                for value in new_config_item.__dict__[field_name]:
                    new_lines.append("{}={}".format(name, value))
            else:
                new_lines.append("{}={}".format(name, new_config_item.__dict__[field_name]))
    elif new_config_item == None and section_index == total_sections - 1:
        # We deleted the last section. Trim any blank lines we left at the end of the file.
        while len(new_lines) > 0 and len(new_lines[-1].strip()) == 0:
            del new_lines[-1]

    # Save the file
    if new_lines != lines:
        if CliOptions.dry_run:
            if new_config_item == None and total_sections == 1:
                # Deleted the last item.
                print("")
                print("would delete file: " + os.path.relpath(config_file_path))
                print("")
            elif not os.path.exists(config_file_path):
                print("")
                print("would create file: " + os.path.relpath(config_file_path))
                print("with contents:")
                print("")
                for line in new_lines:
                    print(line.rstrip())
                print("")
            else:
                # use `git diff <blob> <blob>` to show the changes
                # use `git ls-tree` to get the 'from' blob object name.
                # use `git hash-object` to get the 'to' blob object name.
                git("diff",
                    git("ls-tree",
                        "HEAD",
                        "--",
                        os.path.relpath(config_file_path),
                        mode="single_line",
                    ).split("\t")[0].rsplit(" ", 1)[1],
                    git("hash-object",
                        "-w", "--stdin",
                        input="".join(
                            line.rstrip() + "\n"
                            for line in new_lines
                        ),
                        mode="single_line",
                    ),
                    mode="inherit_stdout",
                )
        else:
            # Actually do it.
            if new_config_item == None and total_sections == 1:
                # Deleted the last item.
                try:
                    os.remove(config_file_path)
                except FileNotFoundError:
                    pass
                git("update-index",
                    "--remove",
                    os.path.relpath(config_file_path),
                    mode="mutating")
            else:
                with open(config_file_path, "w") as f:
                    for line in new_lines:
                        f.write(line.rstrip() + "\n")
                git("update-index",
                    "--add",
                    os.path.relpath(config_file_path),
                    mode="mutating")

    if section_index == NEW_SECTION:
        # Return the new section_index.
        if theres_at_least_one_section:
            return current_section_index
        else:
            return 0
    else:
        # You already know your section index.
        return None


def insert_tree_at_path(base_tree_object_name, new_tree_object_name, new_tree_subdir_path):
    def recurse(base, subdir_path):
        if "/" in subdir_path:
            name, rest_of_subdir_path = subdir_path.split("/", 1)
        else:
            name, rest_of_subdir_path = subdir_path, None
        new_ls_tree_lines = []
        inserted_yet = False
        if base != None:
            for ls_tree_line in git("ls-tree",
                "--full-tree",
                "-z",
                base,
                mode="null_terminated_lines",
            ):
                stuff, this_name = ls_tree_line.split("\t", 1)
                if this_name == name:
                    # Update this node.
                    mode_and_type, object_name = stuff.rsplit(" ", 1)
                    assert mode_and_type == "040000 tree", "A non-directory file is in the way: " + new_tree_subdir_path
                    if rest_of_subdir_path != None:
                        ls_tree_line = "040000 tree {}\t{}".format(recurse(object_name, rest_of_subdir_path), name)
                    else:
                        # Overwrite existing content.
                        ls_tree_line = "040000 tree {}\t{}".format(new_tree_object_name, name)
                    inserted_yet = True
                new_ls_tree_lines.append(ls_tree_line)
        if not inserted_yet:
            if rest_of_subdir_path != None:
                tree_object_name = recurse(None, rest_of_subdir_path)
            else:
                tree_object_name = new_tree_object_name
            ls_tree_line = "040000 tree {}\t{}".format(tree_object_name, name)
            new_ls_tree_lines.append(ls_tree_line)
        return git("mktree",
            "-z",
            input="".join(
                line + "\x00"
                for line in new_ls_tree_lines
            ),
            mode="single_line")
    return recurse(base_tree_object_name, new_tree_subdir_path)

def filter_tree(tree_object_name, include_patterns, exclude_patterns):
    depth_to_parent_to_ls_tree_lines = collections.defaultdict(lambda: collections.defaultdict(list), {
        # 3: {"a/b/c": ["100644 blob 615a35da50b4aa9c4525e26aba1cd830010e4e46\t.gitignore"]},
    })

    # Filter the items.
    for ls_tree_line in git("ls-tree",
        "--full-tree", "-r",
        "-z",
        tree_object_name,
        mode="null_terminated_lines",
    ):
        stuff, name = ls_tree_line.split("\t", 1)
        if len(include_patterns) > 0:
            if not any(fnmatch.fnmatch(name, pattern) for pattern in include_patterns):
                continue
        if len(exclude_patterns) > 0:
            if any(fnmatch.fnmatch(name, pattern) for pattern in exclude_patterns):
                continue
        if "/" in name:
            parent, child = name.rsplit("/", 1)
            depth_to_parent_to_ls_tree_lines[len(parent.split("/"))][parent].append("{}\t{}".format(stuff, child))
        else:
            depth_to_parent_to_ls_tree_lines[0][""].append(ls_tree_line)

    # Build new trees from leaves up.
    root_tree = None
    for depth in reversed(range(max(depth_to_parent_to_ls_tree_lines.keys()) + 1)):
        parent_to_ls_tree_lines = depth_to_parent_to_ls_tree_lines[depth]
        assert root_tree == None

        parent_and_ls_tree_lines = list(parent_to_ls_tree_lines.items())
        tree_object_names = git("mktree",
            "-z", "--batch",
            input="".join(
                "".join(
                    ls_tree_line + "\x00"
                    for ls_tree_line in ls_tree_lines
                ) + "\x00"
                for _, ls_tree_lines in parent_and_ls_tree_lines
            ),
            mode="newline_terminated_lines",
        )
        for tree_object_name, (name, _) in zip(tree_object_names, parent_and_ls_tree_lines):
            assert root_tree == None
            if "/" in name:
                parent, child = name.rsplit("/", 1)
                ls_tree_line = "040000 tree {}\t{}".format(tree_object_name, child)
                depth_to_parent_to_ls_tree_lines[len(parent.split("/"))][parent].append(ls_tree_line)
            elif len(name) > 0:
                ls_tree_line = "040000 tree {}\t{}".format(tree_object_name, name)
                depth_to_parent_to_ls_tree_lines[0][""].append(ls_tree_line)
            else:
                # Root tree.
                root_tree = tree_object_name
    assert root_tree != None
    return root_tree


def get_git_commit_tree_object_name(commit_object_name):
    return git("rev-parse",
        "--verify",
        commit_object_name + "^{tree}",
        mode="single_line",
    )

@functools.lru_cache()
def get_repo_root():
    return git("rev-parse",
        "--show-toplevel",
        mode="single_line")

def git(*args, mode, cwd=".", input=None, output_path=None, suppress_stderr=False):
    if type(input) == str:
        input = input.encode("utf8")

    cmd = ["git"]
    cmd.extend(args)

    stderr = None
    if suppress_stderr:
        stderr = subprocess.DEVNULL

    if output_path != None:
        assert mode == "mutating"

    if CliOptions.super_verbose or (CliOptions.verbose and mode == "mutating"):
        shell_script = " ".join(shlex.quote(arg) for arg in cmd)
        if input == b"":
            shell_script = shell_script + " <&-"
        if suppress_stderr:
            shell_script = shell_script + " 2>/dev/null"
        if cwd != None and cwd != ".":
            shell_script = "(cd {} && {})".format(shlex.quote(cwd), shell_script)
        if output_path != None:
            shell_script += " > " + output_path
        if input == None or input == b"":
            if CliOptions.dry_run and mode == "mutating":
                shell_script = "# " + shell_script
        else:
            # some rough heuristic to split the input into "lines" or whatever.
            lines = re.findall(b".+?(?:[\x00\n]+|$)", input, flags=re.DOTALL)
            def quote_for_echo(line):
                if line == b"":
                    return "''"
                if line[0] == b"-":
                    starts_with_hyphen = True
                    line = line[1:]
                else:
                    starts_with_hyphen = False
                # Replace strange bytes with hex escapes (for echo -e).
                def escape_byte(b):
                    if b == b"\n": return b"\\n"
                    if b == b"\t": return b"\\t"
                    return b"\\x" + hex(ord(b))[2:].zfill(2).encode("utf8")
                # We need to keep bytes up through here so we can escape non-ascii correctly.
                s = re.sub(b"[\x00-\x1f\\\\'\x7f-\xff]", (lambda m: escape_byte(m.group())), line).decode("utf8")
                if starts_with_hyphen:
                    # Because you can't echo "-n" literally, this needs extra support
                    s = "\\x2d" + s
                return "'" + s + "'"
            input_script = "{" + "".join(
                "\n  echo -ne " + quote_for_echo(line)
                for line in lines
            ) + "\n}"
            if CliOptions.dry_run and mode == "mutating":
                shell_script = ": #" + shell_script
            shell_script = input_script + " | " + shell_script
        sys.stderr.write(shell_script + "\n"); sys.stderr.flush()

    if mode == "mutating":
        if not CliOptions.dry_run:
            if output_path != None:
                with open(output_path, "wb") as f:
                    subprocess.run(cmd, cwd=cwd, input=input, stdout=f, stderr=stderr, check=True)
            else:
                subprocess.run(cmd, cwd=cwd, input=input, stderr=stderr, check=True)
        return None

    # read-only or otherwise no-observable-change command.

    if mode == "inherit_stdout":
        subprocess.run(cmd, cwd=cwd, input=input, stderr=stderr, check=True)
        return

    if mode == "yield_newline_terminated_lines":
        assert input == None, "not supported"
        process = subprocess.Popen(cmd, cwd=cwd, stdout=subprocess.PIPE, stderr=stderr, encoding="utf8")
        def yield_lines_and_check():
            for line in process.stdout:
                assert line[-1:] == "\n"
                yield line[:-1]
            if process.wait() != 0:
                raise subprocess.CalledProcessError(process.returncode, cmd)
        return yield_lines_and_check()

    output = subprocess.run(cmd, cwd=cwd, input=input, stderr=stderr, check=True, stdout=subprocess.PIPE).stdout
    if mode == "raw_bytes":
        return output
    if mode == "single_line":
        lines = output.decode("utf8").split("\n")
        assert lines[-1] == ""
        [line] = lines[:-1]
        return line
    if mode == "null_terminated_lines":
        lines = output.decode("utf8").split("\x00")
        assert lines[-1] == ""
        return lines[:-1]
    if mode == "newline_terminated_lines":
        lines = output.decode("utf8").split("\n")
        assert lines[-1] == ""
        return lines[:-1]
    assert False, mode

def is_path_within(super_dir, sub_dir):
    super_dir = os.path.abspath(super_dir)
    sub_dir = os.path.abspath(sub_dir)
    return os.path.commonpath([super_dir, sub_dir]).startswith(super_dir)

def validate_dir(dir, param_name):
    repo_root = get_repo_root()
    assert is_path_within(repo_root, dir), param_name + " is outside the git repo"
    path_in_repo = os.path.relpath(dir, repo_root)
    assert path_in_repo != ".", param_name + " must not be the entire repo"
    assert not os.path.exists(dir), param_name + " already exists"
    return path_in_repo.replace(os.path.sep, "/")

def validate_url(url):
    # See `git help fetch` section GIT URLS.
    if re.match(r'^[a-z+.-]+://.*', url) != None:
        # Some kind of url. Should be safe to try at least.
        return
    if re.match(r'^[A-Za-z0-9._-]+@[^/]+:.*', url) != None:
        # Looks like "scp-like syntax"
        return

    if os.path.isabs(url):
        # Absolute paths work as git repo urls.
        if os.path.exists(url):
            warning("Absolute path urls are not portable! (But you probably already knew that.)",
                "--url={}".format(url))
            return
    else:
        # Relative paths are accepted in some git commands, but they're usually canonicalized to be absolute.
        # To actually use a relative path url with this program, please just convert it to absolute first.
        pass

    sys.exit("ERROR: Invalid --url={}".format(url))

def validate_ref(ref):
    # This is really the only thing to check for, because it's interpreted specially during `git fetch` and such.
    if "*" in ref:
        sys.exit("ERROR: Invalid --ref={}".format(ref))

def warning(*lines):
    for line in lines:
        print("WARNING: " + line, file=sys.stderr, flush=True)

if __name__ == "__main__":
    main()
